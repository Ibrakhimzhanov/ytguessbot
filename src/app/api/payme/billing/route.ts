// Billing endpoint –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤ –æ—Ç Payme –∫ –Ω–∞—à–µ–º—É –±–∏–ª–ª–∏–Ω–≥—É
// –≠—Ç–æ—Ç URL –Ω—É–∂–Ω–æ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å Payme –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∫–∞—Å—Å—ã

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { bot } from '@/lib/telegram'

// Merchant API –º–µ—Ç–æ–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å Payme
enum MerchantMethod {
  CHECK_PERFORM_TRANSACTION = 'CheckPerformTransaction',
  CREATE_TRANSACTION = 'CreateTransaction', 
  PERFORM_TRANSACTION = 'PerformTransaction',
  CANCEL_TRANSACTION = 'CancelTransaction',
  CHECK_TRANSACTION = 'CheckTransaction',
  GET_STATEMENT = 'GetStatement'
}

interface MerchantRequest {
  id: number
  method: MerchantMethod
  params: {
    account?: {
      order_id?: string
      user_id?: string
    }
    id?: string
    time?: number
    amount?: number
    from?: number
    to?: number
  }
}

interface MerchantResponse {
  id: number
  result?: any
  error?: {
    code: number
    message: string
    data?: any
  }
}

export async function POST(req: NextRequest) {
  let requestId: number | undefined
  
  try {
    console.log('üîµ Payme Billing Request received')
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
    const authHeader = req.headers.get('Authorization')
    
    // –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ç–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è id
    let body: MerchantRequest | null = null
    try {
      body = await req.json()
      requestId = body.id
      console.log('üìã Payme Request:', JSON.stringify(body, null, 2))
    } catch {
      // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å body, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –±–µ–∑ id
    }
    
    if (!authHeader) {
      return NextResponse.json({
        id: requestId,
        error: {
          code: -32504,
          message: {
            ru: '–ó–∞–≥–æ–ª–æ–≤–æ–∫ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç',
            uz: 'Avtorizatsiya sarlavhasi mavjud emas',
            en: 'Authorization header is missing'
          }
        }
      }, { status: 200 })
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–∑–æ–≤—É—é –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –æ—Ç Payme
    const expectedAuth = Buffer.from(`Paycom:${process.env.PAYME_X_AUTH?.split(':')[1] || ''}`).toString('base64')
    if (authHeader !== `Basic ${expectedAuth}`) {
      return NextResponse.json({
        id: requestId,
        error: {
          code: -32504,
          message: {
            ru: '–ù–µ–≤–µ—Ä–Ω—ã–µ —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏',
            uz: 'Avtorizatsiya ma\'lumotlari noto\'g\'ri',
            en: 'Invalid authorization credentials'
          }
        }
      }, { status: 200 })
    }
    
    // –ï—Å–ª–∏ body —É–∂–µ –ø—Ä–æ—á–∏—Ç–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ, –∏–Ω–∞—á–µ —ç—Ç–æ –æ—à–∏–±–∫–∞
    if (!body) {
      return NextResponse.json({
        id: requestId,
        error: {
          code: -32700,
          message: {
            ru: '–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø—Ä–æ—á–∏—Ç–∞—Ç—å JSON',
            uz: 'JSON o\'qib bo\'lmadi',
            en: 'Unable to parse JSON'
          }
        }
      }, { status: 200 })
    }

    const response: MerchantResponse = { id: body.id }

    switch (body.method) {
      case MerchantMethod.CHECK_PERFORM_TRANSACTION:
        response.result = await checkPerformTransaction(body.params)
        break

      case MerchantMethod.CREATE_TRANSACTION:
        response.result = await createTransaction(body.params)
        break

      case MerchantMethod.PERFORM_TRANSACTION:
        response.result = await performTransaction(body.params)
        break

      case MerchantMethod.CANCEL_TRANSACTION:
        response.result = await cancelTransaction(body.params)
        break

      case MerchantMethod.CHECK_TRANSACTION:
        response.result = await checkTransaction(body.params)
        break

      case MerchantMethod.GET_STATEMENT:
        response.result = await getStatement(body.params)
        break

      default:
        response.error = {
          code: -32601,
          message: {
            ru: '–ú–µ—Ç–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω',
            uz: 'Metod topilmadi',
            en: 'Method not found'
          }
        }
    }

    console.log('üü¢ Payme Response:', JSON.stringify(response, null, 2))
    return NextResponse.json(response)

  } catch (error: any) {
    console.error('‚ùå Payme Billing Error:', error)
    
    // –ï—Å–ª–∏ —ç—Ç–æ –æ—à–∏–±–∫–∞ –æ—Ç –º–µ—Ç–æ–¥–æ–≤ Payme —Å –∫–æ–¥–æ–º –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ–º
    if (error && typeof error === 'object' && 'code' in error) {
      return NextResponse.json({
        id: requestId,
        error: {
          code: error.code,
          message: error.message || {
            ru: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞',
            uz: 'Noma\'lum xato',
            en: 'Unknown error'
          },
          data: error.data
        }
      }, { status: 200 })
    }
    
    // –û–±—â–∞—è –æ—à–∏–±–∫–∞
    return NextResponse.json({
      id: requestId,
      error: {
        code: -32400,
        message: {
          ru: '–ù–µ–≤–µ—Ä–Ω—ã–π –∑–∞–ø—Ä–æ—Å',
          uz: 'Noto\'g\'ri so\'rov',
          en: 'Invalid request'
        },
        data: error instanceof Error ? error.message : 'Unknown error'
      }
    }, { status: 200 })
  }
}

// ============ MERCHANT API METHODS ============

/**
 * –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —Å–æ–∑–¥–∞–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
 */
async function checkPerformTransaction(params: any) {
  const { account, amount } = params

  if (!account?.order_id) {
    throw { 
      code: -31001, 
      message: {
        ru: 'order_id –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω',
        uz: 'order_id majburiy',
        en: 'order_id is required'
      }
    }
  }

  // –ù–∞–π—Ç–∏ –ø–ª–∞—Ç–µ–∂ –ø–æ –Ω–æ–º–µ—Ä—É –∑–∞–∫–∞–∑–∞
  const payment = await prisma.payment.findFirst({
    where: { orderNumber: parseInt(account.order_id) },
    include: { user: true }
  })

  if (!payment) {
    throw { 
      code: -31050, 
      message: {
        ru: '–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω',
        uz: 'Buyurtma topilmadi',
        en: 'Order not found'
      }
    }
  }

  if (payment.status === 'PAID') {
    throw { 
      code: -31051, 
      message: {
        ru: '–ó–∞–∫–∞–∑ —É–∂–µ –æ–ø–ª–∞—á–µ–Ω',
        uz: 'Buyurtma allaqachon to\'langan',
        en: 'Order already paid'
      }
    }
  }

  if (payment.status === 'CANCELLED') {
    throw { 
      code: -31052, 
      message: {
        ru: '–ó–∞–∫–∞–∑ –æ—Ç–º–µ–Ω–µ–Ω',
        uz: 'Buyurtma bekor qilingan',
        en: 'Order cancelled'
      }
    }
  }

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É–º–º—ã (amount –≤ —Ç–∏–π–∏–Ω–∞—Ö)
  if (amount !== payment.amount) {
    throw { 
      code: -31001, 
      message: {
        ru: '–ù–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞',
        uz: 'Noto\'g\'ri summa',
        en: 'Invalid amount'
      }
    }
  }

  return {
    allow: true
  }
}

/**
 * –°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
 */
async function createTransaction(params: any) {
  const { account, amount, time, id } = params

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–æ–∑–¥–∞–Ω–∏—è
  await checkPerformTransaction(params)

  // –ù–∞–π—Ç–∏ –ø–ª–∞—Ç–µ–∂
  const payment = await prisma.payment.findFirst({
    where: { orderNumber: parseInt(account.order_id) },
    include: { user: true }
  })

  if (!payment) {
    throw { 
      code: -31050, 
      message: {
        ru: '–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω',
        uz: 'Buyurtma topilmadi',
        en: 'Order not found'
      }
    }
  }

  // –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∏ –¥–æ–±–∞–≤–∏—Ç—å paymeId
  await prisma.payment.update({
    where: { id: payment.id },
    data: {
      paymeId: id,
      status: 'PENDING'
    }
  })

  return {
    create_time: time,
    transaction: payment.orderNumber.toString(),
    state: 1
  }
}

/**
 * –ü—Ä–æ–≤–µ–¥–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ–ø–ª–∞—Ç—ã)
 */
async function performTransaction(params: any) {
  const { id } = params

  const payment = await prisma.payment.findFirst({
    where: { paymeId: id },
    include: { user: true }
  })

  if (!payment) {
    throw { 
      code: -31050, 
      message: {
        ru: '–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞',
        uz: 'Tranzaksiya topilmadi',
        en: 'Transaction not found'
      }
    }
  }

  if (payment.status === 'PAID') {
    return {
      perform_time: payment.completedAt?.getTime() || Date.now(),
      transaction: payment.orderNumber.toString(),
      state: 2
    }
  }

  // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –æ–ø–ª–∞—Ç—É
  const now = new Date()
  await prisma.payment.update({
    where: { id: payment.id },
    data: {
      status: 'PAID',
      completedAt: now
    }
  })

  // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  await prisma.user.update({
    where: { id: payment.userId },
    data: { isPaid: true }
  })

  // –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Telegram
  try {
    await bot.telegram.sendMessage(
      payment.user.telegramId.toString(),
      `üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í–∞—à –ø–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω!\n\n` +
      `‚úÖ –î–æ—Å—Ç—É–ø –∫ –∫—É—Ä—Å—É –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω\n` +
      `üìã –ù–æ–º–µ—Ä –∑–∞–∫–∞–∑–∞: #${payment.orderNumber}\n` +
      `üí∞ –°—É–º–º–∞: ${(payment.amount / 100).toLocaleString()} —Å—É–º\n\n` +
      `üìö –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /mycourse –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º –∫—É—Ä—Å–∞.\n\n` +
      `üéì –ü—Ä–∏—è—Ç–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è!`
    )
  } catch (error) {
    console.error('Failed to notify user via Telegram:', error)
  }

  return {
    perform_time: now.getTime(),
    transaction: payment.orderNumber.toString(),
    state: 2
  }
}

/**
 * –û—Ç–º–µ–Ω–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
 */
async function cancelTransaction(params: any) {
  const { id, reason } = params

  const payment = await prisma.payment.findFirst({
    where: { paymeId: id }
  })

  if (!payment) {
    throw { 
      code: -31050, 
      message: {
        ru: '–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞',
        uz: 'Tranzaksiya topilmadi',
        en: 'Transaction not found'
      }
    }
  }

  if (payment.status === 'CANCELLED') {
    return {
      cancel_time: payment.completedAt?.getTime() || Date.now(),
      transaction: payment.orderNumber.toString(),
      state: -2
    }
  }

  // –û—Ç–º–µ–Ω—è–µ–º –ø–ª–∞—Ç–µ–∂
  const now = new Date()
  await prisma.payment.update({
    where: { id: payment.id },
    data: {
      status: 'CANCELLED',
      completedAt: now
    }
  })

  // –ï—Å–ª–∏ –±—ã–ª –æ–ø–ª–∞—á–µ–Ω, —É–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ç—É—Å —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  if (payment.status === 'PAID') {
    await prisma.user.update({
      where: { id: payment.userId },
      data: { isPaid: false }
    })
  }

  // –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ–± –æ—Ç–º–µ–Ω–µ
  const user = await prisma.user.findUnique({
    where: { id: payment.userId }
  })

  if (user) {
    try {
      await bot.telegram.sendMessage(
        user.telegramId.toString(),
        `‚ùå –ü–ª–∞—Ç–µ–∂ –±—ã–ª –æ—Ç–º–µ–Ω–µ–Ω.\n\n` +
        `üìã –ù–æ–º–µ—Ä –∑–∞–∫–∞–∑–∞: #${payment.orderNumber}\n` +
        `–ü—Ä–∏—á–∏–Ω–∞: ${reason || '–ù–µ —É–∫–∞–∑–∞–Ω–∞'}\n\n` +
        `–ï—Å–ª–∏ —ç—Ç–æ –ø—Ä–æ–∏–∑–æ—à–ª–æ –ø–æ –æ—à–∏–±–∫–µ, –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–∞–Ω–¥—É /buy`
      )
    } catch (error) {
      console.error('Failed to notify user about cancellation:', error)
    }
  }

  return {
    cancel_time: now.getTime(),
    transaction: payment.orderNumber.toString(),
    state: -2
  }
}

/**
 * –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
 */
async function checkTransaction(params: any) {
  const { id } = params

  const payment = await prisma.payment.findFirst({
    where: { paymeId: id }
  })

  if (!payment) {
    throw { 
      code: -31050, 
      message: {
        ru: '–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞',
        uz: 'Tranzaksiya topilmadi',
        en: 'Transaction not found'
      }
    }
  }

  let state: number
  switch (payment.status) {
    case 'PENDING':
      state = 1
      break
    case 'PAID':
      state = 2
      break
    case 'CANCELLED':
      state = -2
      break
    default:
      state = 0
  }

  return {
    create_time: payment.createdAt.getTime(),
    perform_time: payment.completedAt?.getTime() || 0,
    cancel_time: payment.status === 'CANCELLED' ? (payment.completedAt?.getTime() || 0) : 0,
    transaction: payment.orderNumber.toString(),
    state,
    reason: null
  }
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—ã–ø–∏—Å–∫–∏ –ø–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º
 */
async function getStatement(params: any) {
  const { from, to } = params

  const payments = await prisma.payment.findMany({
    where: {
      createdAt: {
        gte: new Date(from),
        lte: new Date(to)
      },
      paymeId: { not: null }
    },
    include: { user: true }
  })

  const transactions = payments.map(payment => {
    let state: number
    switch (payment.status) {
      case 'PENDING':
        state = 1
        break
      case 'PAID':
        state = 2
        break
      case 'CANCELLED':
        state = -2
        break
      default:
        state = 0
    }

    return {
      id: payment.paymeId,
      time: payment.createdAt.getTime(),
      amount: payment.amount,
      account: {
        order_id: payment.orderNumber.toString(),
        user_id: payment.userId
      },
      create_time: payment.createdAt.getTime(),
      perform_time: payment.completedAt?.getTime() || 0,
      cancel_time: payment.status === 'CANCELLED' ? (payment.completedAt?.getTime() || 0) : 0,
      transaction: payment.orderNumber.toString(),
      state,
      reason: null
    }
  })

  return { transactions }
}
